// --- Test 0: MOV ---
// Instruction 1: MOV A, 42
000001000101010
// Instruction 2: MOV B, 123
000001101111011

// --- Test 1: MOV Register to Register ---
// Instruction 3: MOV B, 85
000001101010101
// Instruction 4: MOV A, 170
000001010101010
// Instruction 5: MOV A, B (A = 85)
000000000000000
// Instruction 6: MOV A, 99
000001001100011
// Instruction 7: MOV B, A (B = 99)
000000100000000

// --- Test 2: ADD (Register and Literal) ---
// Instruction 8: MOV A, 2
000001000000010
// Instruction 9: MOV B, 3
000001100000011
// Instruction 10: ADD A, B  (A = A + B -> A = 2 + 3 = 5)
000010000000000
// Instruction 11: ADD A, 10 (A = A + 10 -> A = 5 + 10 = 15)
000011000001010
// Instruction 12: ADD B, 20 (B = B + 20 -> B = 3 + 20 = 23)
000011100010100

// --- Test 3: SUB (Register and Literal) ---
// Instruction 13: MOV A, 20
000001000010100
// Instruction 14: MOV B, 5
000001100000101
// Instruction 15: SUB A, B  (A = A - B -> A = 20 - 5 = 15)
000100000000000
// Instruction 16: SUB B, A  (B = A - B -> B = 15 - 5 = 10)
000100100000000
// Instruction 17: SUB A, 7  (A = A - Lit -> A = 15 - 7 = 8)
000101000000111
// Instruction 18: SUB B, 10 (B = B - Lit -> B = -10 - 10 = -20)
000101100001010

// --- Test 4: AND (Register and Literal) ---
// Instruction 19: MOV A, 202 (11001010)
000001011001010
// Instruction 20: MOV B, 174 (10101110)
000001110101110
// Instruction 21: AND A, B  (A = A & B -> A = 202 & 174 = 138)
000110000000000
// Instruction 22: AND B, A  (B = B & A -> B = 174 & 138 = 138)
000110100000000

// Instruction 23: MOV A, 240 (11110000)
000001011110000
// Instruction 24: AND A, 85 (A = A & Lit -> A = 240 & 85 = 80)
000111001010101
// Instruction 25: MOV B, 204 (11001100)
000001111001100
// Instruction 26: AND B, 170 (B = B & Lit -> B = 204 & 170 = 136)
000111110101010

// --- Test 5: OR (Register and Literal) ---
// Instruction 27: MOV A, 202 (11001010)
000001011001010
// Instruction 28: MOV B, 174 (10101110)
000001110101110
// Instruction 29: OR A, B  (A = A | B -> A = 202 | 174 = 238)
001000000000000
// Instruction 30: OR B, A  (B = B | A -> B = 174 | 238 = 238)
001000100000000

// Instruction 31: MOV A, 51 (00110011)
000001000110011
// Instruction 32: OR A, 240 (A = A | Lit -> A = 51 | 240 = 243)
001001011110000
// Instruction 33: MOV B, 165 (10100101)
000001110100101
// Instruction 34: OR B, 90 (B = B | Lit -> B = 165 | 90 = 255)
001001101011010

// --- Test 6: NOT Instructions ---
// Instruction 35: MOV A, 170 (10101010)
000001010101010
// Instruction 36: NOT A, A (A = ~A -> A = ~170 = 85)
001010000000000
// Instruction 37: MOV B, 204 (11001100)
000001111001100
// Instruction 38: NOT B, B (B = ~B -> B = ~204 = 51)
001011100000000

// Setup for NOT A, B
// Instruction 39: MOV A, 255 (to be overwritten)
000001011111111
// Instruction 40: MOV B, 240 (11110000, the source)
000001111110000
// Instruction 41: NOT A, B (A = ~B -> A = ~240 = 15)
001010100000000

// Setup for NOT B, A
// Instruction 42: MOV A, 15 (00001111, the source)
000001000001111
// Instruction 43: MOV B, 255 (to be overwritten)
000001111111111
// Instruction 44: NOT B, A (B = ~A -> B = ~15 = 240)
001011000000000

// --- Test 7: XOR (Register and Literal) ---
// Instruction 45: MOV A, 202 (11001010)
000001011001010
// Instruction 46: MOV B, 174 (10101110)
000001110101110
// Instruction 47: XOR A, B (A = A ^ B -> A = 202 ^ 174 = 100)
001100000000000
// Instruction 48: XOR A, B (A = A ^ B -> A = 100 ^ 174 = 202)
001100000000000

// Instruction 49: MOV A, 240 (11110000)
000001011110000
// Instruction 50: MOV B, 170 (10101010)
000001110101010
// Instruction 51: XOR B, A (B = B ^ A -> B = 170 ^ 240 = 90)
001100100000000

// Instruction 52: MOV A, 60 (00111100)
000001000111100
// Instruction 53: XOR A, 255 (A = A ^ Lit -> A = 60 ^ 255 = 195)
001101011111111
// Instruction 54: MOV B, 146 (10010010)
000001110010010
// Instruction 55: XOR B, 102 (B = B ^ Lit -> B = 146 ^ 102 = 244)
001101101100110

// --- Test 8: SHL Instructions ---

// Test Case 1: SHL A, A (A = A << 1)
// A = 5. Result should be 5 << 1 = 10.
// Instruction 56: MOV A, 5 (00000101)
000001000000101
// Instruction 57: SHL A, A
001110000000000

// Test Case 2: SHL B, B (B = B << 1)
// B = 12. Result should be 12 << 1 = 24.
// Instruction 58: MOV B, 12 (00001100)
000001100001100
// Instruction 59: SHL B, B
001111100000000

// Test Case 3: SHL A, B (A = B << 1)
// B = 21. Result for A should be 21 << 1 = 42. B should be unchanged.
// Instruction 60: MOV A, 99 (placeholder, will be overwritten)
000001001100011
// Instruction 61: MOV B, 21 (00010101)
000001100010101
// Instruction 62: SHL A, B
001110100000000

// Test Case 4: SHL B, A (B = A << 1)
// A = 30. Result for B should be 30 << 1 = 60. A should be unchanged.
// Instruction 63: MOV B, 88 (placeholder, will be overwritten)
000001101011000
// Instruction 64: MOV A, 30 (00011110)
000001000011110
// Instruction 65: SHL B, A
001111000000000

// Test Case 5: Overflow Test (B = A << 1)
// A = 192 (11000000). Result for B should be 192 << 1 = 128 (10000000).
// The most significant bit is shifted out. A is unchanged.
// Instruction 66: MOV B, 0 (placeholder, will be overwritten)
000001100000000
// Instruction 67: MOV A, 192 (11000000)
000001011000000
// Instruction 68: SHL B, A
001111000000000

// --- Test 9: SHR Instructions ---

// Test Case 1: SHR A, A (A = A >> 1)
// A = 10. Result should be 10 >> 1 = 5.
// Instruction 69: MOV A, 10 (00001010)
000001000001010
// Instruction 70: SHR A, A
010000000000000

// Test Case 2: SHR B, B (B = B >> 1)
// B = 24. Result should be 24 >> 1 = 12.
// Instruction 71: MOV B, 24 (00011000)
000001100011000
// Instruction 72: SHR B, B
010001100000000

// Test Case 3: SHR A, B (A = B >> 1)
// B = 42. Result for A should be 42 >> 1 = 21. B should be unchanged.
// Instruction 73: MOV A, 99 (placeholder, will be overwritten)
000001001100011
// Instruction 74: MOV B, 42 (00101010)
000001100101010
// Instruction 75: SHR A, B
010000100000000

// Test Case 4: SHR B, A (B = A >> 1)
// A = 60. Result for B should be 60 >> 1 = 30. A should be unchanged.
// Instruction 76: MOV B, 88 (placeholder, will be overwritten)
000001101011000
// Instruction 77: MOV A, 60 (00111100)
000001000111100
// Instruction 78: SHR B, A
010001000000000

// Test Case 5: LSB Discard Test (B = A >> 1)
// A = 13 (00001101). Result for B should be 13 >> 1 = 6 (00000110).
// The LSB (1) is discarded. A is unchanged.
// Instruction 79: MOV B, 0 (placeholder, will be overwritten)
000001100000000
// Instruction 80: MOV A, 13 (00001101)
000001000001101
// Instruction 81: SHR B, A
010001000000000

// --- Test 10: INC B (Increment Register B) ---

// Test Case 1: Basic Increment
// B = 50. Result should be 50 + 1 = 51.
// Instruction 82: MOV B, 50
000001100110010
// Instruction 83: INC B
010010000000000

// Test Case 2: Increment from Zero
// B = 0. Result should be 0 + 1 = 1.
// Instruction 84: MOV B, 0
000001100000000
// Instruction 85: INC B
010010000000000

// Test Case 3: Rollover/Overflow Test
// B = 255. Result should be 255 + 1 = 0 (8-bit overflow).
// Instruction 86: MOV B, 255 (11111111)
000001111111111
// Instruction 87: INC B
010010000000000

// --- Test 11: New Data Memory MOV Instructions ---
// Instruction 88: MOV A, 101
000001001100101
// Instruction 89: MOV B, 202
000001111001010
// Instruction 90: MOV (20), A
010011100010100
// Instruction 91: MOV (21), B
010100000010101
// Instruction 92: MOV A, 0
000001000000000
// Instruction 93: MOV B, 0
000001100000000
// Instruction 94: MOV A, (21)
010010100010101
// Instruction 95: MOV B, (20)
010011000010100

// --- Test 12: Register Indirect MOV ---
// Instruction 96: MOV A, 111
000001001101111
// Instruction 97: MOV B, 50
000001100110010
// Instruction 98: MOV (B), A
010101100000000
// Instruction 99: MOV A, 0
000001000000000
// Instruction 100: MOV A, (B)
010100100000000
// Instruction 101: MOV A, 60
000001000111100
// Instruction 102: MOV B, 222
000001111011110
// Instruction 103: MOV (60), B
010100000111100
// Instruction 104: MOV B, 0
000001100000000
// Instruction 105: MOV B, (A)
010101000000000

// --- Test 13: Memory ADD ---
// Instruction 106: MOV A, 10
000001000001010
// Instruction 107: MOV B, 20
000001100010100
// Instruction 108: MOV (100), B
010100001100100
// Instruction 109: ADD A, (100)
010110001100100
// Instruction 110: MOV B, 15
000001100001111
// Instruction 111: MOV A, 25
000001000011001
// Instruction 112: MOV (101), A
010011101100101
// Instruction 113: ADD B, (101)
010110101100101
// Instruction 114: MOV A, 5
000001000000101
// Instruction 115: MOV B, 110
000001101101110
// Instruction 116: MOV (110), A
010011101101110
// Instruction 117: ADD A, (B)
010111000000000
// Instruction 118: MOV A, 7
000001000000111
// Instruction 119: MOV B, 8
000001100001000
// Instruction 120: ADD (120)
010111101111000
// Instruction 121: MOV A, (120)
010010101111000

// --- Test 14: Memory SUB ---
// Instruction 122: MOV A, 100
000001001100100
// Instruction 123: MOV B, 30
000001100011110
// Instruction 124: MOV (130), B
010100010000010
// Instruction 125: SUB A, (130)
011000010000010
// Instruction 126: MOV B, 50
000001100110010
// Instruction 127: MOV A, 25
000001000011001
// Instruction 128: MOV (131), A
010011110000011
// Instruction 129: SUB B, (131)
011000110000011
// Instruction 130: MOV A, 20
000001000010100
// Instruction 131: MOV B, 140
000001110001100
// Instruction 132: MOV (140), A
010011110001100
// Instruction 133: MOV A, 30
000001000011110
// Instruction 134: SUB A, (B)
011001000000000
// Instruction 135: MOV A, 90
000001001011010
// Instruction 136: MOV B, 80
000001101010000
// Instruction 137: SUB (150)
011001110010110
// Instruction 138: MOV A, (150)
010010110010110

// --- Test 15: Memory AND ---
// AND A,(Dir)
// MOV A, 0b11001100
000001011001100
// MOV B, 0b10101010
000001110101010
// MOV (160), B
010100010100000
// AND A, (160) -> A = 10001000 (136)
011010010100000

// --- Test 16: Memory OR ---
// OR B,(Dir)
// MOV B, 0b11001100
000001111001100
// MOV A, 0b10101010
000001010101010
// MOV (161), A
010011110100001
// OR B, (161) -> B = 11101110 (238)
011100110100001

// --- Test 17: Memory NOT ---
// NOT (Dir),A
// MOV A, 0b10101010
000001010101010
// NOT (162), A -> Mem[162] = 01010101 (85)
011110010100010
// MOV A, (162)
010010110100010

// --- Test 18: Memory XOR ---
// XOR A,(B)
// MOV A, 0b11001100
000001011001100
// MOV B, 163
000001110100011
// MOV (163), A
010011110100011
// MOV A, 0b10101010
000001010101010
// XOR A,(B) -> A = 01100110 (102)
100000100000000

// --- Test 19: Memory SHL ---
// SHL (Dir),A
// MOV A, 0b01010101
000001001010101
// SHL (164), A -> Mem[164] = 10101010 (170)
100001110100100
// MOV A, (164)
010010110100100

// --- Test 20: Memory SHR ---
// SHR (Dir),B
// MOV B, 0b11001100
000001111001100
// SHR (165), B -> Mem[165] = 01100110 (102)
100011110100101
// MOV B, (165)
010011010100101

// --- Test 21: Memory INC ---
// INC (Dir)
// MOV A, 99
000001001100011
// MOV (166), A
010011110100110
// INC (166) -> Mem[166] = 100
100100110100110
// MOV A, (166)
010010110100110

// --- Test 22: Memory RST ---
// RST (B)
// MOV B, 167
000001110100111
// RST (B) -> Mem[167] = 0
100110000000000
// MOV A, (167)
010010110100111
