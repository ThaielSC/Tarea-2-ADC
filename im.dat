// --- Test Case: Full & Expanded Memory Sequence ---
// --- Part 1: Original Test (RegB -> Mem -> RegA) ---
// Inst 0: MOV B, 99      | Loads the immediate value 99 into register B.
000001101100011
// Inst 1: MOV (50), B    | Stores the value from register B into data memory at address 50.
010100000110010
// Inst 2: MOV A, (50)    | Loads the value from data memory at address 50 into register A.
010010100110010

// --- Part 2: Symmetric Test (RegA -> Mem -> RegB) ---
// Inst 3: MOV A, 123     | Loads the immediate value 123 into register A.
000001001111011
// Inst 4: MOV (51), A    | Stores the value from register A into data memory at address 51.
010011100110011
// Inst 5: MOV B, (51)    | Loads the value from data memory at address 51 into register B.
010011000110011

// --- Part 3: Overwrite and Edge Case Test (0 and 255) ---
// Inst 6: MOV A, 255     | Loads the immediate value 255 into register A.
000001011111111
// Inst 7: MOV (50), A    | Stores 255 into DM at address 50, overwriting the previous value.
010011100110010
// Inst 8: MOV A, 0       | Loads the immediate value 0 into register A.
000001000000000
// Inst 9: MOV A, (50)    | Loads the value from DM at address 50 (which is 255) into register A.
010010100110010

// --- Test Case: ADD A, (Dir) ---
// Goal: Verify A = A + Mem[Dir]. Expected result in A is 150.
// Inst 10: MOV A, 100    | Loads the operand 100 into register A.
000001001100100
// Inst 11: MOV B, 50     | Loads the operand 50 into register B.
000001100110010
// Inst 12: MOV (120), B  | Stores the value from register B into memory at address 120.
010100001111000
// Inst 13: ADD A, (120)  | Adds the value from DM[120] to register A (A = 100 + 50 = 150).
010110001111000

// --- Test Case: SUB (Dir) ---
// Goal: Verify Mem[Dir] = A - B. Expected result in DM[200] is 60.
// Inst 14: MOV A, 100    | Loads the minuend (100) into Register A.
000001001100100
// Inst 15: MOV B, 40     | Loads the subtrahend (40) into Register B.
000001100101000
// Inst 16: SUB (200)     | Calculates A - B and stores the result (60) in DM[200].
011001111001000

// --- Test Case: AND A, (B) ---
// Goal: Verify A = A & Mem[B]. Expected result in A is 136.
// Inst 17: MOV A, 170    | Loads the value 170 (10101010b) into A temporarily.
000001010101010
// Inst 18: MOV (150), A  | Stores 170 into memory at address 150.
010011110010110
// Inst 19: MOV A, 204    | Loads the value 204 (11001100b) into Register A.
000001011001100
// Inst 20: MOV B, 150    | Loads the memory address 150 into Register B to act as a pointer.
000001110010110
// Inst 21: AND A, (B)    | A = A & Mem[B] => A = 204 & 170 = 136.
011011000000000

// --- Test Case: OR B, (Dir) ---
// Goal: Verify B = B | Mem[Dir]. Expected result in B is 215.
// Inst 22: MOV B, 195    | Loads the first operand (11000011b) into Register B.
000001111000011
// Inst 23: MOV A, 85     | Loads the second operand (01010101b) into A temporarily.
000001001010101
// Inst 24: MOV (16), A   | Stores the second operand into memory at address 16 (0x10).
010011100010000
// Inst 25: OR B, (16)    | B = B | Mem[16] => B = 195 | 85 = 215.
011100100010000

// --- Test Case: NOT (B) ---
// Goal: Verify Mem[B] = ~A. Expected result in DM[210] is 90.
// Inst 26: MOV A, 165    | Loads the source value (10100101b) into Register A.
000001010100101
// Inst 27: MOV B, 210    | Loads the destination memory address (210) into Register B.
000001111010010
// Inst 28: NOT (B)       | Calculates ~A and stores the result (~165 = 90) in DM[B].
011111000000000

// --- Test Case: XOR A, (Dir) ---
// Goal: Verify A = A ^ Mem[Dir]. Expected result in A is 102.
// Inst 29: MOV A, 202    | Loads the first operand (11001010b) into Register A.
000001011001010
// Inst 30: MOV B, 172    | Loads the second operand (10101100b) into B temporarily.
000001110101100
// Inst 31: MOV (220), B  | Stores the second operand into memory at address 220.
010100011011100
// Inst 32: XOR A, (220)  | A = A ^ Mem[220] => A = 202 ^ 172 = 102.
011111111011100

// --- Test Case: SHL (Dir), B ---
// Goal: Verify Mem[Dir] = B << 1. Expected result in DM[230] is 170.
// Inst 33: MOV B, 85     | Loads the source value (01010101b) into Register B.
000001101010101
// Inst 34: SHL (230), B  | Calculates B << 1 and stores the result (170) in DM[230].
100010011100110

// --- Test Case: SHR (B) ---
// Goal: Verify Mem[B] = A >> 1. Expected result in DM[240] is 106.
// Inst 35: MOV A, 212    | Loads the source value (11010100b) into Register A.
000001011010100
// Inst 36: MOV B, 240    | Loads the destination memory address (240) into Register B.
000001111110000
// Inst 37: SHR (B)       | Calculates A >> 1 and stores the result (106) in DM[B].
100100000000000

// --- Test Case: INC (Dir) ---
// Goal: Verify Mem[Dir] = Mem[Dir] + 1, including overflow.
// --- Part 1: Standard Increment ---
// Inst 38: MOV A, 77     | Load initial value 77 into A.
000001001001101
// Inst 39: MOV (250), A  | Store 77 into memory at address 250.
010011111111010
// Inst 40: INC (250)     | Reads 77 from DM[250], increments it, and writes 78 back.
100100111111010
// --- Part 2: Overflow Test ---
// Inst 41: MOV A, 255    | Load initial value 255 into A.
000001011111111
// Inst 42: MOV (251), A  | Store 255 into memory at address 251.
010011111111011
// Inst 43: INC (251)     | Reads 255 from DM[251], increments it, and writes 0 back (overflow).
100100111111011

// --- Test Case: RST (B) ---
// Goal: Verify Mem[B] = 0.
// Inst 44: MOV A, 123    | Load a non-zero value into A temporarily.
000001001111011
// Inst 45: MOV (255), A  | Store 123 into memory at address 255 to ensure it's not already zero.
010011111111111
// Inst 46: MOV B, 255    | Load the memory address 255 into Register B to act as a pointer.
000001111111111
// Inst 47: RST (B)       | Writes the value 0 to the memory location pointed to by B (DM[255]).
100110000000000

// --- Test Program: IF (A <= Mem[B]) THEN DM[100]=1 ELSE DM[100]=2 ---
// --- Case 2: A = 20, Mem[B] = 20. Expected: DM[100] = 1 ---
// --- Setup ---
// Inst 48: MOV A, 20     | Load 20 into A.
000001000010100
// Inst 49: MOV (200), A  | Store 20 in DM[200].
010011111001000
// Inst 50: MOV B, 200    | B points to the memory operand.
000001111001000
// Inst 51: MOV A, 20     | Load 20 into A, making it equal to Mem[B].
000001000010100
// --- Logic ---
// Inst 52: CMP A, (B)    | Compares A and Mem[B] (20-20), sets Z flag.
101001000000000
// Inst 53: JLE 56        | Jumps to Inst 56 as Z flag is set (condition is true).
101100100111000
// --- "Else" Block (skipped) ---
// Inst 54: MOV B, 2      | Load fail value (2).
000001100000010
// Inst 55: JMP 57        | Unconditionally jump to skip "if" block.
101000000111001
// --- "If" Block (executed) ---
// Inst 56: MOV B, 1      | Load success value (1).
000001100000001
// --- Common Code ---
// Inst 57: MOV (100), B  | Store result (1) into DM[100].
010100001100100

// --- Test Program: FOR Loop ---
// Goal: Emulate for(B=3; B>=0; B--) { Mem[B] = 99; }

// --- Initialization ---
// Inst 58: MOV A, 99
// Description: Load the value 99 into A to be stored in memory.
000001001100011
// Inst 59: MOV B, 3
// Description: Initialize the loop counter B to 3.
000001100000011

// --- Loop Start (Address 60) ---
// Inst 60: CMP B, 0
// Description: Compare B to 0. Sets flags for the JGE instruction.
100111100000000
// Inst 61: JGE 63
// Description: If B >= 0 (N=0), jump to the loop body at address 63. Otherwise, exit loop.
101100000111111
// Inst 62: JMP 66
// Description: Exit loop by jumping to the end of the program at address 66.
101001101000010

// --- Loop Body (Address 63) ---
// Inst 63: MOV (B), A
// Description: Store the value of A into the memory location pointed to by B.
010101100000000
// Inst 64: SUB B, 1
// Description: Decrement B by 1 to simulate B--.
000101100000001
// Inst 65: JMP 60
// Description: Jump back to the start of the loop (address 60) for the next iteration.
101001100111100

// --- End of Program (Address 66) ---
// Inst 66: NOP
// Description: Program halts here after the loop finishes.
000000000000000

